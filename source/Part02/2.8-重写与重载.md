# 2.8 重写与重载

## 重写 @Override

为什么在 `onEnable()`，`onDisable()`，`onCommand()` 等多个方法上面都有一个 `@Override` 的标记？因为 `onEnable()`，`onDisable()`，`onCommand()` 的父类是存在的，我们写插件实际上是在重写父类的这些方法，让 **Bukkit** 遵从我们的意愿去执行任务，就是说，我们编写的类虽然是子类，但 **Bukkit** 在看到我们 `@Override` 的情况下，我们能有更高的优先级，举一个更好理解的例子吧

```javascript
public class Father {
    public void say() {
        System.out.println("这是父类的内容");
    }
}

public class Son extends Father { // 子类继承了父类
    @Override
    public void say() { // 子类重写了父类的 say() 方法
        System.out.println("这是子类的内容");
    }
    public static void main(String[] args) { // 以这样的结构出现的是 Java 程序启动入口，下面是启动将要执行的代码，与 Bukkit 无关
        Son son = new Son();
        son.say();
    }
}
```

```控制台输出
这是子类的内容
```

## 重载 Overload

千万不要与 **重写** 混淆，重载是 **Java** 多态的表现形式，下面是一个 **重载** 的例子，可见 **重载** 要求的是，**同一个方法名**，所需要的 **参数列表不同** **(例如参数的数据类型，或者参数的请求顺序，以及参数的个数)**，另外，重载的 **返回值** 可以 **自定义**！

```javascript
public class Example {
    public static void main(String[] args) {
        Example example = new Example();
        example.say();
        example.say("什么？这怎么可能被运行？"); 
    }
    public void say() {
        System.out.printl("这里很常规，对吧？\n"); // \n 为转义符号，代表换行
    }
    public void say(String str) {
        System.out.printl("重载！"+str);
    }
}
```
```控制台输出
这里很常规，对吧？
重载！什么？这怎么可能被运行？
```

?> **Question.** 如何分清楚 **重写** 与 **重载**？

很简单，它们的出现方式就不一样，**重写** 前面通常带了一个 `@`，而重载，只是 **Java** 多态的表现形式罢了